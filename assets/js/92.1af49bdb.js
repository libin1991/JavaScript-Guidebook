(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{378:function(e,t,_){"use strict";_.r(t);var v=_(0),i=Object(v.a)({},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("div",{staticClass:"content"},[e._m(0),e._v(" "),_("p",[e._v("整个在浏览器的渲染过程中回流（Reflow）和重绘（Repaint）会大大影响 Web 性能，尤其是手机页面。因此我们在页面设计的时候要尽量减少回流和重绘。")]),e._v(" "),_("p",[e._v("渲染过程包括页面初始化、用户行为改变界面样式和动画改变界面样式等。")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),_("p",[e._v("当 DOM 的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，由于流式布局其他元素的几何属性和位置也受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。")]),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),_("p",[e._v("浏览器并不会在我们进行上述操作时立即进行回流，浏览器会积攥一批 Reflow 后批量进行回流，不过有的操作会让浏览器立马进行回流，比如窗口缩放，改变了页面默认的字体，或者说获取以下这些值。")]),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),_("p",[e._v("光栅：光栅主要是针对图形的一个栅格化过程。现代浏览器中主要的绘制工作主要用光栅化软件来完成。所以元素重绘由这个元素和绘制层级的关系，来决定的是否会很大程度影响你的性能-，如果这个元素盖住的多层元素都被重新绘制，性能损耗当然大。")]),e._v(" "),e._m(14),e._v(" "),_("p",[e._v("在网页元素发生变化时，浏览器会尽可能做出最小的响应：")]),e._v(" "),e._m(15),e._v(" "),_("hr"),e._v(" "),e._m(16),e._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://segmentfault.com/a/1190000015851927",target:"_blank",rel:"noopener noreferrer"}},[e._v("📝 学习重流和重绘（reflow 和 repaint）"),_("OutboundLink")],1)]),e._v(" "),_("li",[_("a",{attrs:{href:"https://segmentfault.com/a/1190000016056546",target:"_blank",rel:"noopener noreferrer"}},[e._v("📝 研讨浏览器绘制和 Web 性能的注意事项"),_("OutboundLink")],1)])])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"回流和重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流和重绘","aria-hidden":"true"}},[this._v("#")]),this._v(" 回流和重绘")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流","aria-hidden":"true"}},[this._v("#")]),this._v(" 回流")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("回流（Reflow），也叫重排，会计算页面布局（Layout）。某个节点回流时会"),t("strong",[this._v("重新计算节点的尺寸和位置")]),this._v("，而且还有可能触及其后代节点的回流。回流后，浏览器会重新绘制受影响的部分到屏幕可视区域，该过程称为重绘。另外，DOM 变化不一定都会影响几何属性，比如改变一个元素的背景色不影响宽高，这种情况下只会发生重绘，代价较小。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("回流会从根节点开始递归往下，依次计算所有的结点几何尺寸和位置，在回流过程中，可能会增加一些渲染器，如文本字符串。DOM 树里的每个节点都会有 "),t("code",[this._v("reflow")]),this._v(" 方法，一个结点的回流很有可能导致子节点，甚至父节点以及同级节点的回流。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("回流（Reflow）几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 "),t("code",[this._v("reflow")]),this._v("。鼠标滑过、点击等用户交互事件，只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 "),t("code",[this._v("reflow")]),this._v(" 哪一部分的代码，它们都彼此相互影响着。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("回流的原因：")])])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[_("strong",[e._v("Initial")]),e._v("：网页初始化的时候")]),e._v(" "),_("li",[_("strong",[e._v("Incremental")]),e._v("：JavaScript 在操作 DOM Tree 时")]),e._v(" "),_("li",[_("strong",[e._v("Resize")]),e._v("：某些元件的尺寸变了")]),e._v(" "),_("li",[_("strong",[e._v("StyleChange")]),e._v("：如果 CSS 的属性发生变化了")]),e._v(" "),_("li",[_("strong",[e._v("Dirty")]),e._v("：几个 Incremental 的 Reflow 发生在同一个元素的子树上")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("会导致产生回流的场景：")])])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[e._v("网页初始化")]),e._v(" "),_("li",[e._v("元素内容变化，如输入空间")]),e._v(" "),_("li",[e._v("脚本操作 DOM（增加、删除和修改）")]),e._v(" "),_("li",[e._v("计算 "),_("code",[e._v("offsetWidth")]),e._v(" 和 "),_("code",[e._v("offsetHeight")]),e._v(" 等")]),e._v(" "),_("li",[e._v("改变浏览器窗口大小")]),e._v(" "),_("li",[e._v("设置 style 属性")]),e._v(" "),_("li",[e._v("操作 class 属性")]),e._v(" "),_("li",[e._v("激活伪类，如 "),_("code",[e._v(":hover")])]),e._v(" "),_("li",[e._v("改变文字大小")]),e._v(" "),_("li",[e._v("样式表变动")])])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[_("code",[e._v("offsetTop")]),e._v("、"),_("code",[e._v("offsetLeft")]),e._v("、"),_("code",[e._v("offsetWidth")]),e._v("、"),_("code",[e._v("offsetHeight")])]),e._v(" "),_("li",[_("code",[e._v("scrollTop")]),e._v("、"),_("code",[e._v("scrollLeft")]),e._v("、"),_("code",[e._v("scrollWidth")]),e._v("、"),_("code",[e._v("scrollHeight")])]),e._v(" "),_("li",[_("code",[e._v("clientTop")]),e._v("、"),_("code",[e._v("clientLeft")]),e._v("、"),_("code",[e._v("clientWidth")]),e._v("、"),_("code",[e._v("clientHeight")])]),e._v(" "),_("li",[e._v("IE 中的 "),_("code",[e._v("getComputedStyle()")]),e._v(" 和 "),_("code",[e._v("currentStyle")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("减少回流的方案：")])])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[e._v("不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸")]),e._v(" "),_("li",[e._v("尽量通过 "),_("code",[e._v("class")]),e._v(" 来设计元素样式，切忌使用 "),_("code",[e._v("style")])]),e._v(" "),_("li",[e._v("实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的 "),_("code",[e._v("position")]),e._v(" 属性应当设为 "),_("code",[e._v("fixed")]),e._v(" 或 "),_("code",[e._v("absolute")])]),e._v(" "),_("li",[e._v("权衡速度的平滑。比如实现一个动画，以 1 个像素为单位移动这样最平滑，但回流就会过于频繁，CPU 很快就会被完全占用。如果以 3 个像素为单位移动就会好很多。")]),e._v(" "),_("li",[e._v("不要用 "),_("code",[e._v("table")]),e._v(" 布局的另一个原因就是 "),_("code",[e._v("tables")]),e._v(" 中某个元素一旦触发回流就会导致 "),_("code",[e._v("table")]),e._v(" 里所有的其它元素回流。在适合用 "),_("code",[e._v("table")]),e._v(" 的场合，可以设置 "),_("code",[e._v("table-layout")]),e._v(" 为 "),_("code",[e._v("auto")]),e._v(" 或 "),_("code",[e._v("fixed")]),e._v("。")]),e._v(" "),_("li",[e._v("CSS 里不要有表达式")]),e._v(" "),_("li",[e._v("减少不必要的 DOM 层级。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行回流上面。")]),e._v(" "),_("li",[e._v("避免不必要的复杂的 CSS 选择器，尤其是后代选择器，因为为了匹配选择器将耗费更多的 CPU。")]),e._v(" "),_("li",[e._v("尽量不要过多的频繁的去增加、修改或删除元素，因为这可能会频繁地导致页面回流，可以先把该 DOM 节点抽离道内存中进行复杂的操作然后再 "),_("code",[e._v("display")]),e._v(" 到页面上。")]),e._v(" "),_("li",[e._v("不要逐条地修改 DOM 样式。与其这样，不如预先定义好 CSS 的 "),_("code",[e._v("class")]),e._v("，然后修改 DOM 的 "),_("code",[e._v("className")]),e._v("。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘","aria-hidden":"true"}},[this._v("#")]),this._v(" 重绘")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("重绘（Repaint）遍历所有节点，"),t("strong",[this._v("检测节点的可见性、颜色、轮廓等可见的样式属性")]),this._v("，然后根据检测的结果更新页面的响应部分。当渲染树中的一些元素需要更新一些不会改变元素布局的属性，比如只是影响元素的外观、风格、而不会影响布局的那些属性，这时候就只发生重绘。当然，页面首次加载也是要重绘一次的。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"动态变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态变化","aria-hidden":"true"}},[this._v("#")]),this._v(" 动态变化")])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[e._v("元素颜色的改变：只会对该元素进行"),_("strong",[e._v("重绘")]),e._v("。")]),e._v(" "),_("li",[e._v("元素位置的改变：只会对该元素及其子元素（可能还有同级元素）进行"),_("strong",[e._v("布局和重绘")]),e._v("。")]),e._v(" "),_("li",[e._v("添加 DOM 节点：会对该节点进行"),_("strong",[e._v("布局和重绘")]),e._v("。")]),e._v(" "),_("li",[e._v("一些重大变化（例如增大 "),_("code",[e._v("<html>")]),e._v(" 元素的字体）会导致缓存无效，使得整个渲染树都会进行重新"),_("strong",[e._v("布局")]),e._v("和"),_("strong",[e._v("绘制")]),e._v("。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("参考资料：")])])}],!1,null,null,null);t.default=i.exports}}]);