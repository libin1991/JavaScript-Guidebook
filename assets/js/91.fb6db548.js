(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{376:function(t,e,r){"use strict";r.r(e);var i=r(0),n=Object(i.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),r("p",[t._v("和布局一样，绘制也分为全局和增量两种。")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),r("p",[r("a",{attrs:{href:"http://www.w3.org/TR/CSS21/zindex.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS2 规范"),r("OutboundLink")],1),t._v(" 定义了绘制流程的顺序。绘制的顺序其实就是元素进入 "),r("a",{attrs:{href:"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#stackingcontext",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆栈样式上下文"),r("OutboundLink")],1),t._v(" 的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：")]),t._v(" "),t._m(7),t._v(" "),t._m(8)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#绘制","aria-hidden":"true"}},[this._v("#")]),this._v(" 绘制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在绘制阶段，系统会遍历渲染树，并调用渲染器的 "),e("code",[this._v("paint")]),this._v(" 方法，将渲染器的内容绘制成位图。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("绘制工作是使用用户界面基础组件完成的。你所看见的一切都会触发 "),e("code",[this._v("paint")]),this._v("。包括拖动滚动条，鼠标选择中文字等这些完全不改变样式，只改变显示结果的动作都会触发 "),e("code",[this._v("paint")]),this._v("。")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("p",[r("code",[t._v("paint")]),t._v(" 的工作就是把文档中用户可见的那一部分展现给用户。"),r("code",[t._v("paint")]),t._v(" 是把 "),r("code",[t._v("layout")]),t._v(" 和样式计算的结果直接在浏览器视窗上绘制出来，它并不实现具体的元素计算，只是 "),r("code",[t._v("layout")]),t._v(" 后面的那一步。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"全局绘制和增量绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全局绘制和增量绘制","aria-hidden":"true"}},[this._v("#")]),this._v(" 全局绘制和增量绘制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在增量绘制中，部分渲染器发生了更改，但是不会影响整个树。更改后的渲染器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块 dirty 区域，并生成 "),e("code",[this._v("paint")]),this._v(" 事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的渲染器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历渲染树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"绘制顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#绘制顺序","aria-hidden":"true"}},[this._v("#")]),this._v(" 绘制顺序")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[t._v("背景颜色（background-color）")]),t._v(" "),r("li",[t._v("背景图片（background-image）")]),t._v(" "),r("li",[t._v("边框（border）")]),t._v(" "),r("li",[t._v("子代")]),t._v(" "),r("li",[t._v("轮廓（outline）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在样式发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大 "),e("code",[this._v("<html>")]),this._v(" 元素的字体）会导致缓存无效，使得整个渲染树都会进行重新布局和绘制。")])}],!1,null,null,null);e.default=n.exports}}]);